# 项目介绍

## 已完成功能

1. 消费者与生产者对应关系
   1. 一对一
   2. 多对多
2. 消费者与队列关系
   1. 单点消费（随机推送）
   2. 广播模式（集群广播）
3. 消息推送模式：
   1. `Server` 主动 `Push` 机制
   2. 基于`Ack`的 客户端 `Pull` 机制
4. 队列支持类型
   1. 普通临时队列
   2. 普通持久化队列
   3. 延时（持久化）队列，
5. 延时队列
   1. 每个消息可以指定自己的超时时间
   2. 先过期的消息会优先从队列取出
6. `Ack`模式下，消息的重复消费（延时队列不支持）
   1. 使用方式：只要不返回`Ack`确认标志，该消息就可以一直被重复消费

7. 消息的有序性
   1. 采用单线程的方式将消息放入到队列中，所以队列的消息是有序的

8. 失败重连
   1. 客户端与服务端采用`Tcp`传输模式，当链接断开时，自动触发重连机制

9. 消息发送失败后的重试机制
   1. `Ack`模式下，发送失败后，尝试重新发送，重试上限次数可自定义
   2. 如果消费者不存在，`Server`会进入等待状态，该等待时间可自定义
   3. 注意：集群广播中，由于单点失败，可能会重复广播，导致某些节点重复消费
10. 基于`Protobuf`二进制，自定义消息的传递格式
11. 数据持久化机制
    1. 消息可持久化
    2. `Server`重启后，消息不丢失
    3. 消费者连接`Server`以后，自动推送积压消息
    4. 可设置缓存文件的大小
    5. 持久化机制：同步( 暂时不支持异步）
    6. 持久化消息超过设定的持久化最大值以后，程序自动覆盖最旧的缓存消息文件
12. 自定义 `Spring Starter` 整合 `Spring Boot`
13. 自定义 `KrestMQTemplate` 用于操作 `MQ`，简化发送消息的流程
14. 集群模式
    1. 高可用：
       + `queue` 的副本机制，可自定义副本数，集群会将为每个queue创建响应的副本到不同的机器
       + 客户端失败重连：某个 server 奔溃掉， 客户端可以链接集群中的 其他 server，继续正常工作
    2. 动态扩展
       + 集群针对`queue`进行备份，每个节点的 `queue`可能是不同的，而非节点，所以集群可以进行动态的横向扩展queue，而不影响工作效率，但是需要注意每个queue的名字需要是唯一的，否则会发生异常
    3. 高度承受消息积压的能力：
       + 因为每个节点的`queue`可能是不同的，所以集群承受消息积压的能力也会比较高
    4. 高效的同步策略
       + 采用 `Udp` 传输模式，可以高效传输数据
       + 使用 `Ack` + 重试， 避免在传输数据的时候，丢失消息




## 待优化

1. 目前每个队列的方式采用全量复制，如果积压的消息量很大时，频繁的消息同步，会影响集群的工作性能
2. 集群目前是定时同步消息，可能会有两个问题
   1. 消息的重复消费
   2. 正在与客户端交互的Server突然挂掉后，导致消息丢失



## 考虑中

1. 消息队列的创建有消费者完成，如果生产者传递消息的队列不存在，会返回异常
